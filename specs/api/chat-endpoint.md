# Chat Endpoint Specification

## Overview

The chat endpoint provides the primary interface for users to interact with the Todo App Chatbot. It follows a stateless architecture where all conversation context is retrieved from the database for each request, ensuring horizontal scalability without server-side session state.

## Endpoint Definition

### Path
```
POST /api/{user_id}/chat
```

### Parameters
- **user_id** (path parameter): Unique identifier of the requesting user

## Request Format

### Headers
```
Authorization: Bearer <JWT_TOKEN>
Content-Type: application/json
```

### Body Schema
```json
{
  "type": "object",
  "properties": {
    "conversation_id": {
      "type": ["integer", "null"],
      "description": "Optional existing conversation ID, if null a new conversation will be created"
    },
    "message": {
      "type": "string",
      "minLength": 1,
      "maxLength": 10000,
      "description": "The user's message to the chatbot"
    }
  },
  "required": ["message"],
  "additionalProperties": false
}
```

### Example Request
```json
{
  "conversation_id": 123,
  "message": "Add a task to buy groceries"
}
```

## Response Format

### Success Response (200 OK)
```json
{
  "type": "object",
  "properties": {
    "conversation_id": {
      "type": "integer",
      "description": "The ID of the conversation (newly created or existing)"
    },
    "response": {
      "type": "string",
      "description": "The assistant's response message"
    },
    "tool_calls": {
      "type": ["array", "null"],
      "items": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the MCP tool called"
          },
          "arguments": {
            "type": "object",
            "description": "Arguments passed to the tool"
          }
        },
        "required": ["name", "arguments"]
      },
      "description": "Optional array of MCP tool calls executed"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "Timestamp of the response"
    }
  },
  "required": ["conversation_id", "response", "timestamp"],
  "additionalProperties": false
}
```

### Example Response
```json
{
  "conversation_id": 123,
  "response": "I've created a task: 'buy groceries'. Is there anything else you'd like to add?",
  "tool_calls": [
    {
      "name": "add_task",
      "arguments": {
        "user_id": "user123",
        "title": "buy groceries",
        "priority": "medium"
      }
    }
  ],
  "timestamp": "2026-01-13T12:00:00Z"
}
```

## Stateless Flow Process

### Step 1: Receive Message
- Accept the incoming POST request with user message
- Validate the request format and headers
- Extract user_id from path and message from body

### Step 2: Validate Authorization Token
- Extract JWT token from Authorization header
- Verify token signature and validity
- Confirm token corresponds to the user_id in the path

### Step 3: Get/Create Conversation
- If conversation_id is provided in request:
  - Verify the conversation exists and belongs to the user
  - If conversation doesn't exist, return 404 error
- If conversation_id is null:
  - Create a new conversation record in the database
  - Assign the new conversation to the authenticated user

### Step 4: Fetch Conversation History
- Retrieve all messages associated with the conversation from the database
- Order messages chronologically (oldest first)
- Limit to last N messages if conversation is very long (pagination)

### Step 5: Construct Agent Context
- Combine the conversation history with the new user message
- Format the context appropriately for the orchestrator agent
- Include any relevant user preferences or settings

### Step 6: Process with Orchestrator Agent
- Pass the constructed context to the orchestrator agent
- Allow the agent to determine intent and select appropriate tools
- Execute any required MCP tools based on agent decisions

### Step 7: Execute MCP Tool Calls
- Process any tool calls generated by the orchestrator agent
- Validate tool parameters and user permissions
- Execute tools and collect results

### Step 8: Generate Assistant Response
- Format the tool execution results into a natural language response
- Ensure the response addresses the user's original message
- Maintain conversational flow and context

### Step 9: Store New Messages
- Save the user's message to the database with role "user"
- Save the assistant's response to the database with role "assistant"
- Include any tool calls in the message record if applicable

### Step 10: Update Conversation Metadata
- Update the conversation's updated_at timestamp
- Potentially update conversation metadata based on the interaction
- Ensure all changes are committed to the database

### Step 11: Return Response
- Format the response according to the response schema
- Include the conversation_id for continuity
- Add the assistant's response message
- Include any tool calls that were executed

## Error Handling

### 401 Unauthorized
- **Cause**: Invalid, expired, or missing JWT token
- **Response**:
```json
{
  "error": "unauthorized",
  "message": "Invalid or missing authentication token",
  "code": "AUTH_001"
}
```

### 403 Forbidden
- **Cause**: Token is valid but user_id in path doesn't match token
- **Response**:
```json
{
  "error": "forbidden",
  "message": "Access denied: user_id does not match authentication",
  "code": "AUTH_002"
}
```

### 404 Not Found
- **Cause**: Provided conversation_id does not exist or doesn't belong to user
- **Response**:
```json
{
  "error": "not_found",
  "message": "Conversation not found or access denied",
  "code": "CHAT_001"
}
```

### 422 Unprocessable Entity
- **Cause**: Invalid request format or missing required fields
- **Response**:
```json
{
  "error": "validation_error",
  "message": "Invalid request format",
  "details": {
    "field": "message",
    "issue": "Message is required and cannot be empty"
  },
  "code": "VALIDATION_001"
}
```

### 500 Internal Server Error
- **Cause**: Unexpected server error during processing
- **Response**:
```json
{
  "error": "server_error",
  "message": "An unexpected error occurred while processing your request",
  "code": "SERVER_001"
}
```

## Security Requirements

### JWT Token Validation
- Verify token signature using configured secret/public key
- Validate token expiration (exp claim)
- Confirm token issuer (iss claim) matches expected value
- Verify subject (sub claim) matches user_id in path

### User Identity Matching
- Ensure the authenticated user matches the user_id in the path parameter
- Prevent users from accessing conversations belonging to other users
- Validate that the JWT token's subject matches the requested user_id

### Data Isolation
- All database queries must filter by user_id to prevent cross-user data access
- Conversation records must be tied to the authenticated user
- Message history retrieval must be limited to user's own conversations
- Tool execution must validate that user has permission to operate on requested resources

### Input Sanitization
- Sanitize user input to prevent injection attacks
- Validate message length to prevent resource exhaustion
- Apply rate limiting per user to prevent abuse
- Log security-relevant events for monitoring

### Rate Limiting
- Implement per-user rate limiting (e.g., 100 requests per minute)
- Track request frequency and reject excessive requests
- Return 429 status code when limits are exceeded

## Performance Requirements

### Response Time
- 95% of requests should respond within 3 seconds
- Complex operations may take up to 5 seconds but should provide feedback
- Implement timeouts for external service calls

### Concurrency
- Support at least 1000 concurrent connections
- Scale horizontally without session affinity
- Database connections should be pooled appropriately

## Monitoring and Logging

### Required Logs
- Request/response pairs (excluding sensitive data)
- Authentication attempts and results
- Tool execution events
- Error occurrences with context
- Performance metrics

### Privacy Considerations
- Do not log actual message content in plain text
- Encrypt sensitive data in logs
- Retain logs only as long as necessary
- Anonymize user data where possible in logs